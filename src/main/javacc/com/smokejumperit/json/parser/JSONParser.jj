
options {
	CHOICE_AMBIGUITY_CHECK=3;
	OTHER_AMBIGUITY_CHECK=2;
	//DEBUG_PARSER=true
	//DEBUG_LOOKAHEAD=true
	//DEBUG_TOKEN_MANAGER=true
	ERROR_REPORTING=true;
	JAVA_UNICODE_ESCAPE=true;
	UNICODE_INPUT=true;
	IGNORE_CASE=true;
	SUPPORT_CLASS_VISIBILITY_PUBLIC=false;
	FORCE_LA_CHECK=true;
	CACHE_TOKENS=true;
  SANITY_CHECK = true;
	STATIC=false;
  //KEEP_LINE_COLUMN=true;
}

PARSER_BEGIN(JSONParser)

package com.smokejumperit.json.parser;

import java.io.*;
import java.util.*;
import java.math.*;

/**
* Basic JSON parser generated by JavaCC. It consumes the input provided through the constructor when 
* {@code parseObject()}, {@code parseList()}, or {@code parse()} are called, and there is no way to directly
* reset the state.
* Set the {@code fallbackToString} property if you want to enable
* unparseable constructs (such as unqouted strings) to be handled as Strings: otherwise, they are a parse
* error.
*
* <p />
*
* This class makes no pretenses towards being threadsafe.
*/
public class JSONParser {

	private boolean fallbackToString = true;

	public JSONParser(String input) {
    this(new StringReader(input));
  }

	public LinkedHashMap<String,Object> parseObject() throws ParseException { return object(); }

	public ArrayList<Object> parseList() throws ParseException { return list(); }

	public Object parse() throws ParseException { return anything(); }

	/**
	*	Get whether unparseable value-looking things should be treated as a string.
	*/
	public boolean getFallbackToString() { 
		return fallbackToString;
	}

	/**
	*	Set whether unparseable value-looking things should be treated as a string.
	*/
	public void setFallbackToString(boolean value) {
		fallbackToString = value;
	}

}

PARSER_END(JSONParser)

// Ignore comments
SKIP: {
	<C_SINGLE_COMMENT: "//" (~["\n","\r","\f"])* <EOL>>
| <C_MULTILINE_COMMENT: "/*" (~[])* "*/">
| <SH_SINGLE_COMMENT: "#" (~["\n","\r","\f"])* <EOL>>
}

// Ignore white space (mostly)
SKIP : { " " | "\t" }
TOKEN: { <EOL: "\n" | "\r" | "\f"> }

// Common tokens
TOKEN: {
	<COMMA: ",">
}

// Object tokens
TOKEN:{
	<BRACE_OPEN: "{">
| <BRACE_CLOSE: "}">
| <COLON: ":">
}

// Array tokens
TOKEN:{
	<BRACKET_OPEN: "[">
| <BRACKET_CLOSE: "]">
}

// Number token
TOKEN:{
	<#ZERO: "0">
| <#DIGIT_NONZERO: ["1"-"9"]>
| <#DIGIT: (<DIGIT_NONZERO> | <ZERO>) >
| <NUMBER: 
		("-")?  
		( <ZERO> | ( <DIGIT_NONZERO> (<DIGIT>)* ) ) 
		("." 
			(<DIGIT>)+
			(
				["e","E"]
				("+" | "-")?
				(<DIGIT>)+
			)?
		)?
	>
}

// Boolean tokens
TOKEN:{
	<TRUE: "true">
| <FALSE: "false">
}

// Null token
TOKEN:{
	<NULL: "null">
}

// String tokens
TOKEN:{
	<QUOTE_DOUBLE: "\"">
| <QUOTE_SINGLE: "'">
}
TOKEN:{
	<STRING_SINGLE_EMPTY: "''">
| <STRING_DOUBLE_EMPTY: "\"\"">
| <STRING_SINGLE_BODY: (
		(~["'","\\","\r","\n","\f"]) |
		( "\\" ( "r" | "n" | "f" | "\\" | "/" | "'" | "b" | "t" ) )
	)+>
| <STRING_DOUBLE_BODY: (
		(~["\"","\\","\r","\n","\f"]) |
		( "\\" ( "r" | "n" | "f" | "\\" | "/" | "\"" | "b" | "t" ) )
	)+>
}


void eof() : {}{
	<EOF>
}

Object anything() : { 
	Object x;
}{
	( x = object()
	| x = list()
	| x = value()
	)
	{ return x; }
}

LinkedHashMap<String,Object> object() : {
	final LinkedHashMap<String,Object> map = new LinkedHashMap<String,Object>();
	String key;
	Object value;
}{
	<BRACE_OPEN>
	[
		key = string()
		value = anything()
		{ map.put(key, value); }
		{ key = null; value = null; }
		(
			<COMMA>
			key = string()
			value = anything()
			{ map.put(key, value); }
			{ key = null; value = null; }
		)*
	]
	<BRACE_CLOSE>
	{ return map; }
}

ArrayList<Object> list() : {
	final ArrayList<Object> list = new ArrayList<Object>(); 
	Object value;
}{
	<BRACKET_OPEN>
	[
		value = anything()
		{ list.add(value); }
		{ value = null; }
		(
			<COMMA>
			value = anything()
			{ list.add(value); }
			{ value = null; }
		)*
	]
	<BRACKET_CLOSE>
	{ return list; }
}

Object value() : {
	Object x;
}{
	( x = string()
	| x = number()
	| x = booleanValue()
	| x = nullValue()
	| LOOKAHEAD({ fallbackToString }) (
		x = unquotedValue()
	)
	)
	{ return x; }
}

Object nullValue(): {}{
	<NULL>
	{ return null; }
}

Boolean booleanValue(): {
	Boolean b;
}{
	(
		<TRUE>
		{ b = Boolean.TRUE; }
	) | (
		<FALSE>
		{ b = Boolean.FALSE; }
	)
	{ return b; }
}

BigDecimal number(): {
	Token t;
}{ 
	t = <NUMBER>
	{ return new BigDecimal(t.image); }
}

String unquotedValue(): {
	Token t;
} {
	t = <UNQUOTED_VALUE: (~[",","[","{","\r","\n","\f"])+ >
	{ return t.image; }
}

String string() : {
	String s;
}{
	( s = doubleQuoteString() 
	| s = singleQuoteString()
	)
	{ return s; }
}

String doubleQuoteString() : {
	Token t;
}{
	(
		<STRING_DOUBLE_EMPTY>
		{ return ""; }
	) | (
		<QUOTE_DOUBLE>
		t = <STRING_DOUBLE_BODY>
		<QUOTE_DOUBLE>
		{ return t.image; }
	)
}

String singleQuoteString() : {
	Token t;
}{
	(
		<STRING_SINGLE_EMPTY>
		{ return ""; }
	) | (
		<QUOTE_SINGLE>
		t = <STRING_SINGLE_BODY>
		<QUOTE_SINGLE>
		{ return t.image; }
	)
}
